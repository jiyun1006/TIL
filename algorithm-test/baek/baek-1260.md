## ë°±ì¤€ 1260 DFSì™€ BFS   
> dfsì™€ bfs ë‘˜ ë‹¤ ì‚¬ìš©í•˜ëŠ” ë¬¸ì œ   

<br>

### ğŸ”‹ ë¬¸ì œí’€ì´     

- ë¨¼ì € ê·¸ë˜í”„ íƒìƒ‰ ë¬¸ì œì´ë¯€ë¡œ
  ì£¼ì–´ì§„ ë…¸ë“œ ì •ë³´ë¥¼ ê°€ì§€ê³ , ê·¸ë˜í”„ë¥¼ ì‘ì„±í•œë‹¤.     

```js
const createGraph = (node) => {
  const graph = Array.from(new Array(node + 1), () => []);
  edge.forEach(([start, end]) => {
    // ì–‘ë°©í–¥ ê°„ì„ ì´ë¯€ë¡œ, ì¶œë°œì ê³¼ ë„ì°©ì ì— ê°ê° ì¶”ê°€í•´ì¤€ë‹¤.
    graph[start].push(end);
    graph[end].push(start);
  })
  return graph;
}
```   

<br>

- ì´í›„ì—, `dfs`, `bfs` í•¨ìˆ˜ë¥¼ ì‘ì„±í•´ì¤€ë‹¤.   
- `dfs`ëŠ” ì¬ê·€ë¥¼ í†µí•œ íƒìƒ‰ í•¨ìˆ˜ë¥¼ ë§Œë“¤ê³ , `bfs`ëŠ” íë¥¼ í†µí•œ í•¨ìˆ˜ë¥¼ ë§Œë“ ë‹¤.   

```js
const dfs = (graph, visited, visitedNode, start) => {
  if (!visited[start]) {
    visited[start] = 1;
    visitedNode.push(start);
    const endArr = graph[start].sort((a,b) => a-b);
    for (let end of endArr) {
      dfs(graph, visited, visitedNode, end);
    }
  }
  return visitedNode;
}

const bfs = (graph, visited, visitedNode, start) => {
  const queue = [];
  queue.push(start);
  while(queue.length !== 0) {
    start = queue.shift();
    if (!visited[start]) {
      visited[start] = 1;
      visitedNode.push(start);
      queue.push(...graph[start].sort((a, b) => a - b));
      
    }
  }
  return visitedNode;
}
```   

- `dfs`ì˜ ê²½ìš° ë„ì°©ì ì—ì„œì˜ ìƒˆë¡œìš´ ë„ì°©ì ìœ¼ë¡œ ê³„ì†í•´ì„œ íƒìƒ‰í•œë‹¤.     

```js
const endArr = graph[start].sort((a,b) => a-b);
    for (let end of endArr) {
      dfs(graph, visited, visitedNode, end);
  }
```   


- í•˜ì§€ë§Œ `bfs`ì˜ ê²½ìš°ì—ëŠ” ì²˜ìŒ ë„ì°©ì ì—ì„œì˜ ìƒˆë¡œìš´ ë„ì°©ì ë¶€í„° ë§ˆë¬´ë¦¬í•˜ê³ , ë‹¤ìŒ ë…¸ë“œë¡œ íƒìƒ‰ì„í•œë‹¤.   
  ë”°ë¼ì„œ íë¥¼ ì´ìš©í•´ ë“¤ì–´ì˜¨ ìˆœì„œëŒ€ë¡œ, íƒìƒ‰ì„ í•˜ê²Œ í•´ì¤€ë‹¤.    

```js
const queue = [];
queue.push(start);
while(queue.length !== 0) {
    start = queue.shift();

    // ---- ìƒëµ ----
  }
```   

<br><br>


---

> ì „ì²´ì½”ë“œ   

```js
const fs = require("fs");
const filepath = process.platform === 'linux' ? '/dev/stdin' : './ex.txt';


let input = fs.readFileSync(filepath).toString().trim().split('\n');

const [node, __, startPoint] = input.shift().split(" ").map(Number);
const edge = input.map((el) => el.split(" ").map(Number));


const solve = (start, type) => {
  const graph = createGraph(node);
  let visited = Array.from(new Array(node + 1), () => 0);
  let visitedNode = [];
  switch (type) {
    case 'dfs':
      visitedNode = dfs(graph, visited, visitedNode, start);
      break;
    case 'bfs':
      visitedNode = bfs(graph, visited, visitedNode, start);
      break;
    
  }
  console.log(...visitedNode);
}

const dfs = (graph, visited, visitedNode, start) => {
  if (!visited[start]) {
    visited[start] = 1;
    visitedNode.push(start);
    const endArr = graph[start].sort((a,b) => a-b);
    for (let end of endArr) {
      dfs(graph, visited, visitedNode, end);
    }
  }
  return visitedNode;
}

const bfs = (graph, visited, visitedNode, start) => {
  const queue = [];
  queue.push(start);
  while(queue.length !== 0) {
    start = queue.shift();
    if (!visited[start]) {
      visited[start] = 1;
      visitedNode.push(start);
      queue.push(...graph[start].sort((a, b) => a - b));
      
    }
  }
  return visitedNode;
}


// ë…¸ë“œ ê·¸ë˜í”„ ë§Œë“œëŠ” í•¨ìˆ˜.
const createGraph = (node) => {
  const graph = Array.from(new Array(node + 1), () => []);
  edge.forEach(([start, end]) => {
    graph[start].push(end);
    graph[end].push(start);
  })
  return graph;
}


const typeArr = ['dfs', 'bfs'];
for (let type of typeArr) {
  solve(startPoint, type); 
}
```

  